# Choosing tables structure and joining

## Best practices in table structures (e.g. normalisation)

Think of your database like a messy bedroom:
- If you design the storage in your room well when you first move in then it's easier to regularly add to it/ update it/ keep it tidy.
- This helps to prevent costly and time intensive problems later on.
- It's important to ensure your room is regularly cleaned and tidied to keep it in good shape and to clear out clutter/ duplicates of things that take up space but don't serve a purpose.

### TOP TIPS FOR A TIDY/ GOOD DATABASE

- Always have a primary key
- Cut out redundant/useless values
- Avoid duplicates of values - to avoid not all versions being updated if the data is changed.
- Avoid illogical structures (bad for compatibility, scaling and for accessibility)
- Make column names easy to search for. Not too long or too short. Bad example: 'ID' as the letters i and d may appear as part of other column names.
- Don't make untested changes to a production database.

- Beware of using a spreadsheet as the basis for a table! It may not be normalised.
- Avoid creating tables lots of columns e.g. over 20. Think in a similar vein to modularising functions in js.
- Think carefully before utilising lots of different extensions, it could create compatibility issues in the future.
- Back up your database
- Refactor

### Follow Normalisation (aka organisation) practices:
- There are 3 tiers of normalisation: First/Second/Third normal form or 1NF, 2NF and 3NF.
- A database falls into a tier according to its lowest common denominator.

- Don't put more than one value in a cell. Ie. Student: 'Marina', Subjects: 'Maths, English'. In this case you should create 2 separate rows for Marina rather than putting the subjects in the same cell.
- A column must depend upon an entire primary key not just part of a concatenated primary key.
- Split out columns into separate tables when their values do not relate to the other column values.
Ie. Student: 'Shireen', Age:23, Subject: 'Maths', Student: 'Shireen', Age:23, Subject: 'English' repeats the age of Shireen even though it's not related to the subjects. It would be better to remove age to a separate table to stop students' ages being duplicated unnecessarily.
- Create new tables so that columns are reliant on a relevant primary key. Move columns that are dependent on another column to a new table if the column they rely on is not the primary key.
Ie. Zip code should be the primary key for other address columns. Doing this helps avoid duplications and make the data easier to understand/use.

## What is a primary key and why is it useful?

Each table within a relational database needs a primary key column. The purpose of a primary key is to make a clear distinction between each entry. This prevents abiguity, as there can be no duplicates. You will have heard of this 'unique identifier' coencept before in everyday life, in the context of an employee number on your payslips, your banking customer reference number, your library number, etc etc. Realistically, your name, address, and any other info about you just isn't unique enough :scream:

Another useful element of primary keys is to speed up specific queries. For example, trying to find a particular user by querying the surname `Smith` would take far longer than looking up their primary key.

### How to create a table with a primary key

The primary key column can be automatically generated by the database, or we can choose a column of the table to perform this function.

Here's an example where we make the product number (`product_no`) the primary key of our `product` table:
```
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
```

One very important property of a primary key is that it can never be `null`! If you think about it, it would be pretty useless as a reference point otherwise e.g. if your customer reference number could be blank. Likewise, once created, a primary key can never be altered so that its value is `null`.

The primary key for each table is stored in an index. You can think of this like the index page in a book. It enforces the uniqueness requirement.


### Choosing a primary key
Think about what a primary key is for - it's supposed to uniquely identify the entry. So good choices might be:
- National Insurance Number
- License Plate Number


--------------------
THIS SECTION IS MORE USEFUL FOR DATABASE DESIGN DECISIONS, WHEN YOUR DATABASE IS GETTING LARGE. FEEL FREE TO SKIP AHEAD FOR NOW.

#### Short keys
The SQL Server query processor uses the primary key for lookups and comparisons. So the briefer the index entries, the faster your queries can be.

#### Processing speed
In terms of improving the processing speed, it is worth choosing primary keys with no embedded spaces, special characters, or differentiation between lowercase and uppercase values.

Data types:
1. The integer data type is the best choice of for your primary key
2. Fixed-length character

This difference in efficiency is down to the way that SQL Server deals with characters: by converting them to their ASCII equivalent before processing.

Variable-length character data types are even worse, because SQL Server has to decompress variable-length character data before processing the data. This extra step consumes valuable processing power.

#### A value that will never change
A bad example would be to choose your customer's address as their primary key. If the customer moves house, you would have to assign them a new primary key, which would mess with their transaction history.

Another good reason for this never to change is that each time a primary key was changed, the associated foreign key in other tables would each have to be updated too.

So a primary key that never changes may seem like an obvious idea. But sometimes primary keys are created which contain real-world meanings. _It is generally better for primary keys not to be based on intrinsic meaning that is related to the individual e.g. the first 2 digits of your customer reference number correspond to your house number._ One notable exceptions to this is the customer reference number assigned to you by your bank, which sometimes uses the customer's DOB. This is a safer choice, as each person's DOB will never change.

-----------------

## How do you join separate tables?

Joining allows you to relate data in one table to the data in other tables.

#### Inner join

Suppose you want to get data from two tables named A (containing customer data) and B (containing payment data). Table B has the `customer_id` field that relates to the primary key (`customer_id`) of the table A.

The INNER JOIN clause returns rows in table A that have the corresponding rows in the table B.

<img src="tables-structure-img/inner-join.png" width="300"/>

__Example:__

Table A

| customer_id    | first_name     | last_name      |
| :------------- | :------------- | :------------- |
| usr0001        | Mary           | Smith          |
| usr0002        | Patricia       | Johnson        |
| usr0003        | Peter          | Menard         |

Table B

| payment_id     | amount         | customer_id    |
| :------------- | :------------- | :------------- |
| p078           | 50             | usr0002        |
| p079           | 10             | usr0001        |
| p090           | 25             | usr0001        |
| p091           | 100            | usr0004        |

To join table A to table B:  
- SELECT clause: specify the columns in both tables from which you want to select data  
- FROM clause: specify the main table  
- INNER JOIN clause: specify the table that the main table joins, the ON keyword and the condition for joining  

``` sql
SELECT * FROM A  
INNER JOIN B ON A.customer_id = B.customer_id;  
```

Result:

| customer_id    | first_name     | last_name      | payment_id     | amount         |
| :------------- | :------------- | :------------- | :------------- | :------------- |
| usr0001        | Mary           | Smith          | p079           | 10             |
| usr0001        | Mary           | Smith          | p090           | 25             |
| usr0002        | Patricia       | Johnson        | p078           | 50             |

#### Left join

The LEFT JOIN clause returns the rows in table A that may or may not have corresponding rows in the table B.

<img src="tables-structure-img/left-join.png" width="300"/>

``` sql
SELECT * FROM A  
LEFT [OUTER] JOIN B ON A.customer_id = B.customer_id;  
```

Result:

| customer_id    | first_name     | last_name      | payment_id     | amount         |
| :------------- | :------------- | :------------- | :------------- | :------------- |
| usr0001        | Mary           | Smith          | p079           | 10             |
| usr0001        | Mary           | Smith          | p090           | 25             |
| usr0002        | Patricia       | Johnson        | p078           | 50             |
| usr0003        | Peter          | Menard         | (null)         | (null)         |

#### Full outer join

The OUTER JOIN clause returns the rows in table A that may or may not have corresponding rows in the table B, as well as all rows in table B that do not have corresponding rows in table A.

<img src="tables-structure-img/outer-join.png" width="300"/>

``` sql
SELECT * FROM A    
FULL [OUTER] JOIN B ON A.customer_id = B.customer_id;  
```

Result:

| customer_id    | first_name     | last_name      | payment_id     | amount         |
| :------------- | :------------- | :------------- | :------------- | :------------- |
| usr0001        | Mary           | Smith          | p079           | 10             |
| usr0001        | Mary           | Smith          | p090           | 25             |
| usr0002        | Patricia       | Johnson        | p078           | 50             |
| usr0003        | Peter          | Menard         | (null)         | (null)         |
| (null)         | (null)         | (null)         | p091           | 100            |

#### Other types of joins

To return all rows in table A that do not have corresponding rows in table B:

<img src="tables-structure-img/example4.png" width="300"/>

``` sql
SELECT * FROM A  
LEFT JOIN B ON A.customer_id = B.customer_id
WHERE B.customer_id IS null;
```
To return all rows unique to Table A and all rows unique to Table B:

<img src="tables-structure-img/example5.png" width="300"/>

``` sql
SELECT  
 *
FROM  
 A  
FULL JOIN B ON A.customer_id = B.customer_id
WHERE A.customer_id IS null
OR B.customer_id IS null
```

#### Differences between inner / outer joins

This difference between inner and outer joins is commonly demonstrated using ~~buttocks~~ Venn Diagrams.
Why buck years of tradition?

![Venn Diagram of Inner and Outer link](images/inout.png)


IMAGINE TWO CIRCLES. THEY ARE PARTIALLY OVERLAPPING. THERE ARE THREE AREAS TO THIS DIAGRAM. THESE ARE THE INSIDE, THE OUTSIDE LEFT, THE OUTSIDE RIGHT. Lets call them I, L, and R.

These two circles are secretly tables, the area within them represents the data that they contain.

Essentially Inner join will make a new table with the shared values of the joined values. It makes a new table which includes the data in I

Outer Join can be used in three different ways.
It can return L + I, R + I, or   L + R + I

http://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join

![Complete Join Diagram](images/vens.png)

## Give a practical example of a database with at least 2 tables.

This example database shows a possible database used by an online store.

![erd](images/sql-model.jpg)

This diagram may be initally confusing as rows in the diagram correspond to columns of data in the actual table. If you imagine this diagram as representation of what information is included in the actual database you should be okay!

## Resources

Normalisation resources:  
- http://www.studytonight.com/dbms/database-normalization.php,
- http://agiledata.org/essays/dataNormalization.html

Table joining resources:  
- [A Visual Explanation of SQL Joins](https://blog.codinghorror.com/a-visual-explanation-of-sql-joins/)
- [PostgreSQL Tutorial](http://www.postgresqltutorial.com/), section 4


